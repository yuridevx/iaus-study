import type { LibraryConfig, CurveConfig } from './types';

export const generateLibraryCode = (config: LibraryConfig): string => {
  const T = config.numericType === 'float' ? 'float' : 'double';
  const suffix = config.numericType === 'float' ? 'f' : '';
  const MathExp = config.mathLibrary === 'unity' ? 'Mathf.Exp' : 'MathF.Exp';
  const MathPow = config.mathLibrary === 'unity' ? 'Mathf.Pow' : 'MathF.Pow';
  const MathLog = config.mathLibrary === 'unity' ? 'Mathf.Log' : 'MathF.Log';
  const MathSin = config.mathLibrary === 'unity' ? 'Mathf.Sin' : 'MathF.Sin';
  const MathCos = config.mathLibrary === 'unity' ? 'Mathf.Cos' : 'MathF.Cos';
  const MathPI = config.mathLibrary === 'unity' ? 'Mathf.PI' : 'MathF.PI';

  const xmlDoc = (text: string) => config.includeXmlDocs ? `    /// <summary>${text}</summary>\n` : '';

  let code = `// ResponseCurves.cs - IAUS Response Curve Library
// Generated by IAUS Study - https://yuridevx.github.io/iaus-study/
using System;
using System.Runtime.CompilerServices;
${config.mathLibrary === 'unity' ? 'using UnityEngine;\n' : ''}
namespace UtilityAI
{
`;

  if (config.includeInterface) {
    code += `${xmlDoc('Common interface for all response curves')}    public interface ICurve
    {
        ${T} Evaluate(${T} input);
    }

`;
  }

  // Helper for clamping
  code += `    internal static class CurveHelpers
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ${T} Clamp01(${T} x) => x < 0${suffix} ? 0${suffix} : (x > 1${suffix} ? 1${suffix} : x);
    }

`;

  // Linear Curve
  code += `${xmlDoc('Linear curve: y = mx + b')}    public readonly struct LinearCurve${config.includeInterface ? ' : ICurve' : ''}
    {
        public readonly ${T} Slope, Intercept, XShift, YShift;
        public readonly bool Invert;

        public LinearCurve(${T} slope = 1${suffix}, ${T} intercept = 0${suffix}, ${T} xShift = 0${suffix}, ${T} yShift = 0${suffix}, bool invert = false)
        {
            Slope = slope; Intercept = intercept; XShift = xShift; YShift = yShift; Invert = invert;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ${T} Evaluate(${T} x)
        {
            x -= XShift;
            ${T} result = CurveHelpers.Clamp01(Slope * x + Intercept + YShift);
            return Invert ? 1${suffix} - result : result;
        }
    }

`;

  // Polynomial Curve
  code += `${xmlDoc('Polynomial curve: y = x^n')}    public readonly struct PolynomialCurve${config.includeInterface ? ' : ICurve' : ''}
    {
        public readonly ${T} Exponent, XShift, YShift;
        public readonly bool Invert;

        public PolynomialCurve(${T} exponent = 2${suffix}, ${T} xShift = 0${suffix}, ${T} yShift = 0${suffix}, bool invert = false)
        {
            Exponent = exponent; XShift = xShift; YShift = yShift; Invert = invert;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ${T} Evaluate(${T} x)
        {
            x = CurveHelpers.Clamp01(x - XShift);
            ${T} result = CurveHelpers.Clamp01(${MathPow}(x, Exponent) + YShift);
            return Invert ? 1${suffix} - result : result;
        }
    }

`;

  // Exponential Curve
  code += `${xmlDoc('Exponential curve: y = (base^x - 1) / (base - 1)')}    public readonly struct ExponentialCurve${config.includeInterface ? ' : ICurve' : ''}
    {
        public readonly ${T} Base, XShift, YShift;
        public readonly bool Invert;

        public ExponentialCurve(${T} @base = 2${suffix}, ${T} xShift = 0${suffix}, ${T} yShift = 0${suffix}, bool invert = false)
        {
            Base = @base; XShift = xShift; YShift = yShift; Invert = invert;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ${T} Evaluate(${T} x)
        {
            x = CurveHelpers.Clamp01(x - XShift);
            ${T} result = Base == 1${suffix} ? x : (${MathPow}(Base, x) - 1${suffix}) / (Base - 1${suffix});
            result = CurveHelpers.Clamp01(result + YShift);
            return Invert ? 1${suffix} - result : result;
        }
    }

`;

  // Logarithmic Curve
  code += `${xmlDoc('Logarithmic curve: y = log(1 + x*(base-1)) / log(base)')}    public readonly struct LogarithmicCurve${config.includeInterface ? ' : ICurve' : ''}
    {
        public readonly ${T} Base, XShift, YShift;
        public readonly bool Invert;

        public LogarithmicCurve(${T} @base = 10${suffix}, ${T} xShift = 0${suffix}, ${T} yShift = 0${suffix}, bool invert = false)
        {
            Base = @base; XShift = xShift; YShift = yShift; Invert = invert;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ${T} Evaluate(${T} x)
        {
            x = CurveHelpers.Clamp01(x - XShift);
            ${T} result = Base <= 1${suffix} ? x : ${MathLog}(1${suffix} + x * (Base - 1${suffix})) / ${MathLog}(Base);
            result = CurveHelpers.Clamp01(result + YShift);
            return Invert ? 1${suffix} - result : result;
        }
    }

`;

  // Logistic Curve
  code += `${xmlDoc('Logistic (sigmoid) curve: y = 1 / (1 + e^(-k*(x-m)))')}    public readonly struct LogisticCurve${config.includeInterface ? ' : ICurve' : ''}
    {
        public readonly ${T} Steepness, Midpoint, XShift, YShift;
        public readonly bool Invert;

        public LogisticCurve(${T} steepness = 10${suffix}, ${T} midpoint = 0.5${suffix}, ${T} xShift = 0${suffix}, ${T} yShift = 0${suffix}, bool invert = false)
        {
            Steepness = steepness; Midpoint = midpoint; XShift = xShift; YShift = yShift; Invert = invert;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ${T} Evaluate(${T} x)
        {
            x -= XShift;
            ${T} result = 1${suffix} / (1${suffix} + ${MathExp}(-Steepness * (x - Midpoint)));
            result = CurveHelpers.Clamp01(result + YShift);
            return Invert ? 1${suffix} - result : result;
        }
    }

`;

  // Smoothstep Curve
  code += `${xmlDoc('Smoothstep curve: y = 3x² - 2x³')}    public readonly struct SmoothstepCurve${config.includeInterface ? ' : ICurve' : ''}
    {
        public readonly ${T} XShift, YShift;
        public readonly bool Invert;

        public SmoothstepCurve(${T} xShift = 0${suffix}, ${T} yShift = 0${suffix}, bool invert = false)
        {
            XShift = xShift; YShift = yShift; Invert = invert;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ${T} Evaluate(${T} x)
        {
            x = CurveHelpers.Clamp01(x - XShift);
            ${T} result = CurveHelpers.Clamp01(x * x * (3${suffix} - 2${suffix} * x) + YShift);
            return Invert ? 1${suffix} - result : result;
        }
    }

`;

  // Smootherstep Curve
  code += `${xmlDoc('Smootherstep curve: y = 6x⁵ - 15x⁴ + 10x³')}    public readonly struct SmootherstepCurve${config.includeInterface ? ' : ICurve' : ''}
    {
        public readonly ${T} XShift, YShift;
        public readonly bool Invert;

        public SmootherstepCurve(${T} xShift = 0${suffix}, ${T} yShift = 0${suffix}, bool invert = false)
        {
            XShift = xShift; YShift = yShift; Invert = invert;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ${T} Evaluate(${T} x)
        {
            x = CurveHelpers.Clamp01(x - XShift);
            ${T} result = CurveHelpers.Clamp01(x * x * x * (x * (x * 6${suffix} - 15${suffix}) + 10${suffix}) + YShift);
            return Invert ? 1${suffix} - result : result;
        }
    }

`;

  // Logit Curve
  code += `${xmlDoc('Logit curve: y = log(x / (1-x)) normalized to 0-1')}    public readonly struct LogitCurve${config.includeInterface ? ' : ICurve' : ''}
    {
        public readonly ${T} Base, XShift, YShift;
        public readonly bool Invert;

        public LogitCurve(${T} @base = 2.718${suffix}, ${T} xShift = 0${suffix}, ${T} yShift = 0${suffix}, bool invert = false)
        {
            Base = @base; XShift = xShift; YShift = yShift; Invert = invert;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ${T} Evaluate(${T} x)
        {
            x = CurveHelpers.Clamp01(x - XShift);
            x = x < 0.001${suffix} ? 0.001${suffix} : (x > 0.999${suffix} ? 0.999${suffix} : x);
            ${T} raw = ${MathLog}(x / (1${suffix} - x)) / ${MathLog}(Base);
            ${T} result = CurveHelpers.Clamp01((raw + 6${suffix}) / 12${suffix} + YShift);
            return Invert ? 1${suffix} - result : result;
        }
    }

`;

  // Gaussian Curve
  code += `${xmlDoc('Gaussian (bell) curve: y = e^(-(x-μ)²/2σ²)')}    public readonly struct GaussianCurve${config.includeInterface ? ' : ICurve' : ''}
    {
        public readonly ${T} Mean, StdDev, XShift, YShift;
        public readonly bool Invert;

        public GaussianCurve(${T} mean = 0.5${suffix}, ${T} stdDev = 0.2${suffix}, ${T} xShift = 0${suffix}, ${T} yShift = 0${suffix}, bool invert = false)
        {
            Mean = mean; StdDev = stdDev; XShift = xShift; YShift = yShift; Invert = invert;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ${T} Evaluate(${T} x)
        {
            x -= XShift;
            ${T} diff = x - Mean;
            ${T} result = CurveHelpers.Clamp01(${MathExp}(-(diff * diff) / (2${suffix} * StdDev * StdDev)) + YShift);
            return Invert ? 1${suffix} - result : result;
        }
    }

`;

  // Step Curve
  code += `${xmlDoc('Step curve: y = x > threshold ? 1 : 0')}    public readonly struct StepCurve${config.includeInterface ? ' : ICurve' : ''}
    {
        public readonly ${T} Threshold, XShift, YShift;
        public readonly bool Invert;

        public StepCurve(${T} threshold = 0.5${suffix}, ${T} xShift = 0${suffix}, ${T} yShift = 0${suffix}, bool invert = false)
        {
            Threshold = threshold; XShift = xShift; YShift = yShift; Invert = invert;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ${T} Evaluate(${T} x)
        {
            x -= XShift;
            ${T} result = CurveHelpers.Clamp01((x > Threshold ? 1${suffix} : 0${suffix}) + YShift);
            return Invert ? 1${suffix} - result : result;
        }
    }

`;

  // Sine Curve
  code += `${xmlDoc('Sine curve: y = (sin(freq * π * x + offset) + 1) / 2')}    public readonly struct SineCurve${config.includeInterface ? ' : ICurve' : ''}
    {
        public readonly ${T} Frequency, Offset, XShift, YShift;
        public readonly bool Invert;

        public SineCurve(${T} frequency = 1${suffix}, ${T} offset = 0${suffix}, ${T} xShift = 0${suffix}, ${T} yShift = 0${suffix}, bool invert = false)
        {
            Frequency = frequency; Offset = offset; XShift = xShift; YShift = yShift; Invert = invert;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ${T} Evaluate(${T} x)
        {
            x -= XShift;
            ${T} result = CurveHelpers.Clamp01((${MathSin}(Frequency * ${MathPI} * x + Offset) + 1${suffix}) / 2${suffix} + YShift);
            return Invert ? 1${suffix} - result : result;
        }
    }

`;

  // Cosine Curve
  code += `${xmlDoc('Cosine curve: y = 1 - cos(freq * π/2 * x)')}    public readonly struct CosineCurve${config.includeInterface ? ' : ICurve' : ''}
    {
        public readonly ${T} Frequency, XShift, YShift;
        public readonly bool Invert;

        public CosineCurve(${T} frequency = 1${suffix}, ${T} xShift = 0${suffix}, ${T} yShift = 0${suffix}, bool invert = false)
        {
            Frequency = frequency; XShift = xShift; YShift = yShift; Invert = invert;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ${T} Evaluate(${T} x)
        {
            x = CurveHelpers.Clamp01(x - XShift);
            ${T} result = CurveHelpers.Clamp01(1${suffix} - ${MathCos}(Frequency * (${MathPI} / 2${suffix}) * x) + YShift);
            return Invert ? 1${suffix} - result : result;
        }
    }

`;

  // Piecewise Linear Curve
  code += `${xmlDoc('Piecewise linear curve: interpolates between defined points')}    public readonly struct PiecewiseLinearCurve${config.includeInterface ? ' : ICurve' : ''}
    {
        public readonly ${T}[] PointsX, PointsY;
        public readonly ${T} XShift, YShift;
        public readonly bool Invert;

        public PiecewiseLinearCurve(${T}[] pointsX, ${T}[] pointsY, ${T} xShift = 0${suffix}, ${T} yShift = 0${suffix}, bool invert = false)
        {
            PointsX = pointsX; PointsY = pointsY; XShift = xShift; YShift = yShift; Invert = invert;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ${T} Evaluate(${T} x)
        {
            x -= XShift;
            if (PointsX == null || PointsX.Length == 0) return Invert ? 1${suffix} : 0${suffix};
            if (PointsX.Length == 1) return CurveHelpers.Clamp01(PointsY[0] + YShift);

            if (x <= PointsX[0]) return CurveHelpers.Clamp01((Invert ? 1${suffix} - PointsY[0] : PointsY[0]) + YShift);
            if (x >= PointsX[PointsX.Length - 1])
            {
                ${T} lastY = PointsY[PointsY.Length - 1];
                return CurveHelpers.Clamp01((Invert ? 1${suffix} - lastY : lastY) + YShift);
            }

            for (int i = 0; i < PointsX.Length - 1; i++)
            {
                if (x >= PointsX[i] && x <= PointsX[i + 1])
                {
                    ${T} t = (x - PointsX[i]) / (PointsX[i + 1] - PointsX[i]);
                    ${T} result = PointsY[i] + t * (PointsY[i + 1] - PointsY[i]);
                    result = CurveHelpers.Clamp01(result + YShift);
                    return Invert ? 1${suffix} - result : result;
                }
            }
            return Invert ? 1${suffix} : 0${suffix};
        }
    }

`;

  // IAUS Scorer
  code += `${xmlDoc('IAUS Utility Scoring helpers')}    public static class IAUSScorer
    {
${xmlDoc('Apply compensation factor to prevent score collapse')}        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ${T} ApplyCompensation(${T} score, int considerationCount)
        {
            ${T} modFactor = 1${suffix} - (1${suffix} / considerationCount);
            return score + ((1${suffix} - score) * modFactor * score);
        }

${xmlDoc('Score with early termination on zero')}        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ${T} ScoreWithTermination(${T} currentScore, ${T} newValue)
        {
            if (newValue <= 0${suffix}) return 0${suffix};
            return currentScore * newValue;
        }
    }
}
`;

  return code;
};

export const generateSingleCurveCode = (curve: CurveConfig, config: LibraryConfig): string => {
  const T = config.numericType === 'float' ? 'float' : 'double';
  const suffix = config.numericType === 'float' ? 'f' : '';

  const formatParam = (value: number | undefined, defaultVal: number): string => {
    const v = value ?? defaultVal;
    return `${v}${suffix}`;
  };

  let structName = '';
  let params = '';

  switch (curve.type) {
    case 'linear':
      structName = 'LinearCurve';
      params = `slope: ${formatParam(curve.params.slope, 1)}, intercept: ${formatParam(curve.params.intercept, 0)}`;
      break;
    case 'polynomial':
      structName = 'PolynomialCurve';
      params = `exponent: ${formatParam(curve.params.exponent, 2)}`;
      break;
    case 'exponential':
      structName = 'ExponentialCurve';
      params = `@base: ${formatParam(curve.params.base, 2)}`;
      break;
    case 'logarithmic':
      structName = 'LogarithmicCurve';
      params = `@base: ${formatParam(curve.params.base, 10)}`;
      break;
    case 'logistic':
      structName = 'LogisticCurve';
      params = `steepness: ${formatParam(curve.params.steepness, 10)}, midpoint: ${formatParam(curve.params.midpoint, 0.5)}`;
      break;
    case 'logit':
      structName = 'LogitCurve';
      params = `@base: ${formatParam(curve.params.base, Math.E)}`;
      break;
    case 'smoothstep':
      structName = 'SmoothstepCurve';
      params = '';
      break;
    case 'smootherstep':
      structName = 'SmootherstepCurve';
      params = '';
      break;
    case 'gaussian':
      structName = 'GaussianCurve';
      params = `mean: ${formatParam(curve.params.mean, 0.5)}, stdDev: ${formatParam(curve.params.stdDev, 0.2)}`;
      break;
    case 'step':
      structName = 'StepCurve';
      params = `threshold: ${formatParam(curve.params.threshold, 0.5)}`;
      break;
    case 'sine':
      structName = 'SineCurve';
      params = `frequency: ${formatParam(curve.params.frequency, 1)}, offset: ${formatParam(curve.params.offset, 0)}`;
      break;
    case 'cosine':
      structName = 'CosineCurve';
      params = `frequency: ${formatParam(curve.params.frequency, 1)}`;
      break;
    case 'piecewiseLinear': {
      structName = 'PiecewiseLinearCurve';
      const pts = curve.params.points ?? [{ x: 0, y: 0 }, { x: 1, y: 1 }];
      const xArr = `new ${T}[] { ${pts.map(p => formatParam(p.x, 0)).join(', ')} }`;
      const yArr = `new ${T}[] { ${pts.map(p => formatParam(p.y, 0)).join(', ')} }`;
      params = `pointsX: ${xArr}, pointsY: ${yArr}`;
      break;
    }
    default:
      structName = 'LinearCurve';
      params = '';
  }

  // Add common params
  const xShift = curve.params.xShift ?? 0;
  const yShift = curve.params.yShift ?? 0;
  if (xShift !== 0) params += `${params ? ', ' : ''}xShift: ${formatParam(xShift, 0)}`;
  if (yShift !== 0) params += `${params ? ', ' : ''}yShift: ${formatParam(yShift, 0)}`;
  if (curve.invert) params += `${params ? ', ' : ''}invert: true`;

  return `// ${curve.name}
var ${curve.name.replace(/[^a-zA-Z0-9]/g, '')}Curve = new ${structName}(${params});
${T} score = ${curve.name.replace(/[^a-zA-Z0-9]/g, '')}Curve.Evaluate(input);`;
};

import type { Consideration } from './types';

export const generateScorerCode = (considerations: Consideration[], config: LibraryConfig): string => {
  const T = config.numericType === 'float' ? 'float' : 'double';
  const suffix = config.numericType === 'float' ? 'f' : '';

  if (considerations.length === 0) {
    return '// No considerations defined';
  }

  let code = '// IAUS Scorer\n';

  // Generate curve instantiations
  considerations.forEach((c, i) => {
    const curveLine = generateSingleCurveCode(c.curve, config).split('\n')[1];
    code += curveLine.replace('Curve = new', `Curve${i} = new`) + '\n';
  });

  code += `\n${T} score = 1${suffix};\n`;

  considerations.forEach((_, i) => {
    code += `score = IAUSScorer.ScoreWithTermination(score, curve${i}.Evaluate(input${i}));\n`;
  });

  code += `score = IAUSScorer.ApplyCompensation(score, ${considerations.length});`;

  return code;
};
